import { NextResponse } from 'next/server';
import connectDb from '@/Lib/database';
import { generateRunnerNameAndLore } from '@/Lib/ai';

export async function GET(request) {
  // --- SÉCURITÉ ---
  // Vérifier si on est en production et si CRON_SECRET est défini
  if (process.env.NODE_ENV === 'production' && process.env.CRON_SECRET) {
    const authHeader = request.headers.get('authorization');
    if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {
      return new NextResponse('Unauthorized', { status: 401 });
    }
  }

  // --- VÉRIFICATION ENVIRONNEMENT ---
  // Ne fonctionne qu'en production
  if (process.env.NODE_ENV !== 'production') {
    return NextResponse.json({ 
      success: true, 
      message: 'Génération automatique désactivée en développement' 
    });
  }

  try {
    await connectDb();
    
    // --- LOGIQUE DE GÉNÉRATION ALÉATOIRE ---
    const now = new Date();
    const currentHour = now.getHours();
    
    // Heures de génération : 8h à 20h (journée active)
    const isActiveHours = currentHour >= 8 && currentHour <= 20;
    
    if (!isActiveHours) {
      return NextResponse.json({ 
        success: true, 
        message: `Hors des heures actives (${currentHour}h), aucune génération.` 
      });
    }

    // Probabilité de génération selon l'heure
    const hourProbabilities = {
      8: 0.4,   // Début de journée
      9: 0.5,
      10: 0.6,
      11: 0.7,
      12: 0.8,  // Heure de pointe
      13: 0.8,
      14: 0.7,
      15: 0.6,
      16: 0.7,
      17: 0.8,  // Heure de pointe
      18: 0.8,
      19: 0.7,
      20: 0.5   // Fin de journée
    };

    const generationProbability = hourProbabilities[currentHour] || 0.5;
    const shouldGenerate = Math.random() < generationProbability;

    if (!shouldGenerate) {
      return NextResponse.json({ 
        success: true, 
        message: `Pas de génération cette fois (probabilité: ${(generationProbability * 100).toFixed(1)}%)` 
      });
    }

    // --- GÉNÉRATION DE RUNNERS ---
    // Nombre de runners à générer (1-2 selon l'heure)
    const maxToGenerate = currentHour >= 12 && currentHour <= 18 ? 2 : 1;
    const toGenerate = Math.min(maxToGenerate, 3); // Maximum 3 par exécution

    const results = [];
    
    for (let i = 0; i < toGenerate; i++) {
      try {
        // Générer des compétences aléatoires
        const skills = {
          hacking: Math.floor(Math.random() * 10) + 1,
          stealth: Math.floor(Math.random() * 10) + 1,
          combat: Math.floor(Math.random() * 10) + 1,
        };
        
        const totalPower = skills.hacking + skills.stealth + skills.combat;
        
        // Générer le nom et le lore par IA
        let runnerName, runnerLore;
        try {
          const { name, lore } = await generateRunnerNameAndLore(skills);
          runnerName = name;
          runnerLore = lore;
        } catch (error) {
          console.error("[AUTO-RUNNERS] Erreur IA, utilisation du fallback:", error);
          // Fallback avec des noms prédéfinis
          const fallbackNames = [
            'Neo', 'Cipher', 'Ghost', 'Shadow', 'Echo', 'Void', 'Pulse', 'Static',
            'Flicker', 'Glitch', 'Phantom', 'Specter', 'Wraith', 'Shade', 'Mirage',
            'Raven', 'Crow', 'Vulture', 'Hawk', 'Falcon', 'Eagle', 'Owl', 'Bat',
            'Spider', 'Scorpion', 'Viper', 'Cobra', 'Python', 'Anaconda', 'Rattlesnake'
          ];
          runnerName = fallbackNames[Math.floor(Math.random() * fallbackNames.length)];
          runnerLore = null;
        }
        
        // Calculer la commission basée sur la puissance totale
        const commission = Math.floor(totalPower * 50) + 200;
        
        results.push({
          id: `auto-runner-${Date.now()}-${i}`,
          name: runnerName,
          lore: runnerLore,
          skills,
          commission,
          totalPower,
          autoGenerated: true,
          generatedAt: new Date()
        });

        console.log(`[AUTO-RUNNERS] Runner créé: ${runnerName} (H:${skills.hacking} S:${skills.stealth} C:${skills.combat}, Commission: ${commission}€$)`);
        
      } catch (error) {
        console.error(`[AUTO-RUNNERS] Erreur lors de la génération du runner ${i + 1}:`, error);
      }
    }

    return NextResponse.json({ 
      success: true, 
      generated: results.length,
      currentTotal: results.length, // Pour l'instant, on ne stocke pas en DB
      hour: currentHour,
      probability: generationProbability,
      runners: results
    });

  } catch (error) {
    console.error('[AUTO-RUNNERS] Erreur générale:', error);
    return new NextResponse('Erreur interne du serveur', { status: 500 });
  }
} 